Good requirements are fundamental to successful software development, ensuring clarity, preventing misunderstandings, and guiding the entire project from conception to implementation.

According to the sources, **good requirements** should exhibit several key qualities:

*   **Establish a Common Understanding** Good requirements foster a shared understanding among all stakeholders, including the sponsor, project manager, business stakeholders, and technical team. They act as a single source of truth across diverse teams like technical, business, compliance, and domain experts. A written specification effectively aligns humans on shared goals, enabling discussion, debate, and synchronization.
*   **Provide a Roadmap for Development** They offer a clear path for the development process.
*   **Be Simple, Verifiable, Necessary, and Achievable**.
    *   **Simple**: Each requirement statement should ideally define only one behavior or constraint, avoiding conjunctions like "and," "or," "also," "with" which can lead to missed requirements. Complex requirements should be split into discrete test cases. Supporting information, such as rationales or exception scenarios, should be separated from the main requirement statement to prevent it from becoming overly complex and unclear.
    *   **Verifiable / Testable**: Requirements must be stated in a way that allows for an objective test to be defined. This includes specifying measurable acceptance criteria like thresholds, formats, or timing. For example, instead of "the system should respond quickly," a good requirement would state "the system must respond to 95% of queries within 500 milliseconds". The verification method and criteria should also be included. For AI, this means translating abstract ethical principles into concrete, testable requirements, such as measurable fairness criteria.
    *   **Necessary**: All described functions should be essential and collectively sufficient to meet the system's needs, goals, and objectives.
    *   **Achievable / Feasible**: Requirements must be realistic and technically possible with available resources.

In addition to these core principles, good requirements incorporate several best practices:

*   **Be Clear, Specific, and Unambiguous in Wording**. Vague or subjective language such as "easy," "straightforward," "intuitive," "efficient," or "reliable" should be avoided. Instead, define precisely what makes a system "intuitive" or "reliable" in measurable terms. Strong requirements use active voice (e.g., "the system shall provide") and express definite statements, avoiding suggestions or possibilities (e.g., "might," "may," "could"). "To be determined" should be avoided; instead, provide the best estimate with rationale. In compatibility requirements, specific needs should be explicitly stated rather than left to interpretation.
*   **Focus on "What," Not "How"** Functional requirements should specify the required external output behavior for given inputs, stating **what** the system must do, not **how** it must do it. Design details or descriptions of operations belong in non-functional requirements or separate design documents.
*   **Be Traceable** Requirements should be traceable back to the business case, project vision, or parent requirement. Each requirement needs a project-unique identifier. Traceability helps understand interdependencies, analyze change impacts, and provides context (the business "WHY") and an audit trail.
*   **Use a Basic, Best-Practice Format and Standardized Language** A standard structure like "Unique ID: Object + Provision/Imperative (shall) + Action + Condition + [optional] Declaration of Purpose /Expected Occurrence (will)" is recommended. Methods like EARS (Easy Approach to Requirements Syntax) offer proven patterns for different requirement types (e.g., General, Event Driven, State Driven). Terms should be defined and used consistently; for example, **SHALL** for binding, verifiable functional requirements, **MUST** for quality/performance non-functional requirements, **WILL** for statements of fact, and **SHOULD** for attributes or best practices.
*   **Include Additional and Supporting Information** Rationale statements, assumptions, directives (pointers to external information), and exception scenarios enhance understanding without cluttering the main requirement statement.
*   **Write from a User Perspective and Vet with a Diverse Team** Requirements should consider the needs of all potential stakeholders and be written from their perspective, ideally containing a user role, the desired state, and a testable metric. Evaluating requirements with a diverse, cross-functional team (including designers, developers, testers, legal, compliance, product managers, and end-user representatives) helps uncover blind spots and ensures all stakeholder needs are met.
*   **Ensure Completeness** Check for all types of requirements, including functional, performance, interface, environment, training, personnel, operability, safety/security, appearance, physical characteristics, and design.
*   **Incorporate Quantifiable Performance Metrics** Especially for AI development, selecting appropriate evaluation metrics (e.g., precision, recall, F1 scores for classification; coherence, relevance, factual accuracy for generative models) is crucial. Both technical (model accuracy) and business impact metrics (user satisfaction) should be defined, with clear baseline thresholds and improvement targets. Subjective criteria should be operationalized into measurable rubrics.
*   **Propose Ethical Guidelines and Safety Guardrails (for AI)** Conduct systematic risk assessments early to identify potential harms and biases. Translate abstract ethical principles into concrete, testable requirements, and implement safety guardrails like content filtering rules or human oversight protocols.
*   **Be Constructive and Executable** Ideally, specifications are **executable**, meaning they can be run to provide immediate feedback on the behavior of the future software. This allows for early validation on an abstract level, increasing correctness and reducing costly rework. Executable specifications should still be property-oriented and declarative, stating **what** is to be computed in a form largely independent of **how** it is computed. They should generate solutions rather than just postulate their existence.
